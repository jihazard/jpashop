# 엘레강트 오브젝트

### 1.1  -er 로 끝나는 이름을 사용하지 마세요 
클래스와 객체의 차이 : 클래스는 객체의 팩토리 입니다. 클래스는 객체를 생성
일반적으로 클래스가 객체를 인스턴스화 한다.

~~~java
class Shape {
    public Shape make(String name) {
        if(name.equals("circle")){
            return new Circle();
        }
        if(name.equals("rectangle")){
            return new Rectangle();
        }
        throw new IllegalArgumentException("not found");
    }
}
~~~ 

##### 클래스 이름을 짓는 적절한 방법 <Br>
- 잘못된 방법 : 클래스의 객체가 무엇을(doing)하고있는지 살핀 후 기능에 기반해 이름을 짓는 방법
~~~java
class CashFormatter {
    private int dollars;
 
    CashFormatter(int dlr) {
        this.dollars = dlr;
    }
 
    public String format() {
        return String.format("$ %d", this.dollars);
    }
}
~~~
 위 클래스가 하는 일 : dollar에 저장된 금액을 문자 열로 포맷팅
 
- 올바른 방법 : 클래스가 무엇을 하는지 (what he does)가 아니라 무엇인지(what he is)에 기반해야 합니다.

CashFormatter라는 이름은 Cash, USDCash 로 변경해야하고 메서드format()은 usd()로 수정

~~~java
class Cash {
    private int dollars;
 
    CashFormatter(int dlr) {
        this.dollars = dlr;
    }
 
    public String usd() {
        return String.format("$ %d", this.dollars);
    }
}
~~~

### 1.2 생성자 하나를 주 생성자로 만드세요 

~~~java
new Cach(30);
new Cach("$30");
new Cach("29.95d");
~~~

- 생성자가 많아질수록 클래스를 유연하게 사용할 수 있다. 하지만 클래스를 사용하기는 어려워 진다.
- public 을 많이 제공하는 방식은 유연성을 저하시기키기 때문에 좋지 않다.

##### 생성자의 주된 작업은 인자를 사용하여 캡슐화하고 프로퍼티를 초기화하는 일이기 때문에 이런 초기화 로직은 주 생성자에만 위치시키고 부생성자에서 주 생성자를 호출하는 방식을 사용하자

~~~java
class Cash {
    private int dollars;
    //부
    Cash(flat dlr) {
        this((int) dlr);
    }
    //부
    Cash(String dlr) {
        this(Cash.parse(dlr));
    }
    //주
    Cash(int dlr) {
        this.dollars = dlr;
    }
}
~~~
- 주 생성자를 맨 뒤에 배치시키는 이유는 유지보수를 위해
